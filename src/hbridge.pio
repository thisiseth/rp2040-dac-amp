.program hbridge

;192mhz = 48k * 32 (oversample) * 25 (PIO period) * 5 (PIO divider)
.define public T_PULSE_CLOCKS 25
.define public T_DEAD_CLOCKS 3 ;lower dead-time gives me a bit less noise, but mosfets get dangerously hot
.define public T_ACTIVE_CLOCKS T_PULSE_CLOCKS - T_DEAD_CLOCKS

.define BRIDGE_PLUS 0b01111

; BRIDGE_MINUS is 0b11110000, but set is limited to only 5 bits
;so we'll have to use mov with bit-inversion

.wrap_target
read_data:
    out x, 1
    jmp x!=y set_output
    jmp read_data [T_PULSE_CLOCKS - 3]
set_output:
    mov y, x
    set x, BRIDGE_PLUS
    jmp !y set_minus
;set_plus
    mov pins, null [T_DEAD_CLOCKS - 1]
    mov pins, x ;BRIDGE_PLUS
    jmp read_data [T_ACTIVE_CLOCKS - 7]
set_minus:
    mov pins, null [T_DEAD_CLOCKS - 1]
    mov pins, ~x ;BRIDGE_MINUS
    jmp read_data [T_ACTIVE_CLOCKS - 7]

% c-sdk {
static inline void hbridge_program_init(PIO pio, uint sm, uint offset, uint pin) 
{
    pio_gpio_init(pio, pin);
    pio_gpio_init(pio, pin + 1);
    pio_gpio_init(pio, pin + 2);
    pio_gpio_init(pio, pin + 3);
    pio_gpio_init(pio, pin + 4);
    pio_gpio_init(pio, pin + 5);
    pio_gpio_init(pio, pin + 6);
    pio_gpio_init(pio, pin + 7);

    pio_sm_set_consecutive_pindirs(pio, sm, pin, 8, true);

    gpio_set_drive_strength(pin, GPIO_DRIVE_STRENGTH_12MA);
    gpio_set_drive_strength(pin + 1, GPIO_DRIVE_STRENGTH_12MA);
    gpio_set_drive_strength(pin + 2, GPIO_DRIVE_STRENGTH_12MA);
    gpio_set_drive_strength(pin + 3, GPIO_DRIVE_STRENGTH_12MA);
    gpio_set_drive_strength(pin + 4, GPIO_DRIVE_STRENGTH_12MA);
    gpio_set_drive_strength(pin + 5, GPIO_DRIVE_STRENGTH_12MA);
    gpio_set_drive_strength(pin + 6, GPIO_DRIVE_STRENGTH_12MA);
    gpio_set_drive_strength(pin + 7, GPIO_DRIVE_STRENGTH_12MA);

    pio_sm_config c = hbridge_program_get_default_config(offset);

    sm_config_set_out_pins(&c, pin, 8);

    sm_config_set_out_shift(&c, true, true, 32);
    sm_config_set_fifo_join(&c, PIO_FIFO_JOIN_TX);

    sm_config_set_clkdiv_int_frac(&c, 5, 0);

    pio_sm_init(pio, sm, offset, &c);
}

static inline void hbridge_program_start(PIO pio, uint sm) 
{
    pio_sm_restart(pio, sm);
    pio_sm_set_enabled(pio, sm, true);
}

static inline void hbridge_program_stop(PIO pio, uint sm) 
{
    pio_sm_set_enabled(pio, sm, false);
    pio_sm_drain_tx_fifo(pio, sm);
    pio_sm_set_pins(pio, sm, 0);
}
%}
